<!DOCTYPE html>
<html lang="en">

<head>
	<title>Block party!</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>

	<!-- javascript libraries -->
	<script src="js/libs/three.min.js"></script>
	<script src="js/libs/stats.min.js"></script>

	<script src="js/libs/PointerLockControls.js"></script>
	<script src="js/libs/Detector.js"></script>
	<script src="js/libs/ConvexGeometry.js"></script>
	<script src="js/libs/OrbitControls.js"></script>

	<!-- our own javascript objects -->
	<script src="js/Room.js"></script>
	<script src="js/Wall.js"></script>
	<script src="js/BlockGenerator.js"></script>

	<!-- other javascript functions -->
	<script src="js/controls.js"></script>
	<script src="js/mechanics.js"></script>
	<script src="js/gameUtils.js"></script>

<!--     <div id="blocker">

        <div id="instructions">
            <span style="font-size:40px">Click to play</span>
            <br />
            (W,A,S,D = Move, SPACE = Jump, MOUSE = Look, CLICK = Place Voxel)
        </div>

    </div> -->


	<script>

		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

		var container, stats;
		var camera, scene, renderer;
		var projector, plane, cube;
		var mouse2D, mouse3D, raycaster,
		rollOveredFace, isShiftDown = false,
		theta = 45 * 0.5, isCtrlDown = false,
		isEqualsDown = false, isDashDown = false;
		var blockNoise = new Audio("sounds/wood-cracking-1.wav");
		var collisionNoise = new Audio("sounds/beep-03.mp3");

		var rollOverMesh, rollOverMaterial;
		var rollOverColor;
		var voxelPosition = new THREE.Vector3(), tmpVec = new THREE.Vector3(), normalMatrix = new THREE.Matrix3();
		var cubeGeo, cubeMaterial;
		var i, intersector;

		var controls, time = Date.now();
		var instructions = document.getElementById( 'instructions' );
		var mouseFlag = true;

		var STEP_SIZE = 50;

        //list to hold blocks we created
        var block_list = new Array();

		// includePointerLockControls();
		init();
		animate();

		function init() {

			container = document.createElement( 'div' );
			document.body.appendChild( container );

			var info = document.createElement( 'div' );
			info.style.position = 'absolute';
			info.style.top = '10px';
			info.style.width = '100%';
			info.style.textAlign = 'center';
			info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> - voxel painter - webgl<br><strong>click</strong>: add voxel, <strong>control + click</strong>: remove voxel, <strong>-</strong>: zoom out, <strong>=</strong>: zoom in';
			container.appendChild( info );

			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
			camera.position.x = 0;
			camera.position.y = 200;
			camera.position.z = 200;

			scene = new THREE.Scene();

			// pointer lock controls
			// controls = new THREE.PointerLockControls( camera );
			// scene.add( controls.getObject() );
			controls = new THREE.OrbitControls( camera );
			controls.rotateSpeed = 0.5;
			controls.minPolarAngle = 0.0;
			controls.maxPolarAngle = Math.PI * 4 / 9;
			scene.add( controls );

			// start with random block
			rollOverMesh = BlockGenerator.getRandomBlock();
			scene.add( rollOverMesh );
			rollOverMesh.position.x = 25; rollOverMesh.position.y = 25; rollOverMesh.position.z = 25;

			// cubes
			// cubeGeo = new THREE.CubeGeometry( 50, 50, 50 );
			// cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xfeb74c, ambient: 0x00ff80, shading: THREE.FlatShading, map: THREE.ImageUtils.loadTexture( "textures/square-outline-textured.png" ) } );
			// cubeMaterial.ambient = cubeMaterial.color;

			// picking

			projector = new THREE.Projector();
			mouse2D = new THREE.Vector3( 0, 10000, 0.5 );

			// basic scene
			var floor = new Wall(1000);

			floor.addToScene(scene);

			// Lights

			var ambientLight = new THREE.AmbientLight( 0x3c3c3c );
			scene.add( ambientLight );

			var directionalLight = new THREE.DirectionalLight( 0xffffff );
			directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
			scene.add( directionalLight );

			// directionalLight = new THREE.DirectionalLight( 0xffffff );
			// directionalLight.position.set( -1, 0.75, 0.5 ).normalize();
			// scene.add( directionalLight );

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setClearColor( 0xf0f0f0 );
			renderer.setSize( window.innerWidth, window.innerHeight );

			container.appendChild( renderer.domElement );

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			container.appendChild( stats.domElement );

			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			document.addEventListener( 'keydown', onDocumentKeyDown, false );
			document.addEventListener( 'keyup', onDocumentKeyUp, false );
			window.addEventListener( 'resize', onWindowResize, false );

		}


		function animate() {
			requestAnimationFrame( animate );
			move();
			render();
			stats.update();
		}


		function render() {
			raycaster = projector.pickingRay( mouse2D.clone(), camera );

			// var intersects = raycaster.intersectObjects( scene.children );

			// if ( intersects.length > 0 ) {
			// 	intersector = getRealIntersector( intersects );

			// 	if ( intersector ) {
			// 		setVoxelPosition( voxelPosition, intersector );
			// 		rollOverMesh.position = voxelPosition;
			// 	}
			// }



			// check if collision
			// TODO: move this to move key - only check when we're moving the block
			// if (hasCollision()) {
			// 	rollOverMesh.material.color.set(0xFF0000);
			// }
			// else {
			// 	rollOverMesh.material.color.set(0x0000FF);
			// }

			renderer.render(scene,camera);
			// controls.update( Date.now() - time );
			renderer.render( scene, camera );
			time = Date.now();
		}

	</script>

</body>


</html>

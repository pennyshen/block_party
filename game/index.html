<!DOCTYPE html>
<html lang="en">

<head>
	<title>Block party!</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>

	<!-- javascript libraries -->
	<script src="js/libs/three.min.js"></script>
	<script src="js/libs/stats.min.js"></script>

	<script src="js/libs/PointerLockControls.js"></script>
	<script src="js/libs/Detector.js"></script>
	<script src="js/libs/ConvexGeometry.js"></script>
	<script src="js/libs/OrbitControls.js"></script>

	<!-- our own javascript objects -->
	<script src="js/Room.js"></script>
	<script src="js/Wall.js"></script>
	<script src="js/BlockGenerator.js"></script>

	<!-- other javascript functions -->
	<script src="js/controls.js"></script>
	<script src="js/gameUtils.js"></script>

    <div id="blocker", onclick=startGame()>
        <div id="instructions">
            <span style="font-size:60px">Click to play</span>
            <br />
            <br />
            W,A,S,D = Move
            <br /> 
            SPACE = Place piece
            <br />
            MOUSE WHEEL = Zoom
            <br />
            LEFT CLICK and DRAG = Rotate camera
            <br />
            RIGHT CLICK and DRAG = Pan camera
            <br />
            SHIFT = Toggle bounding box
        </div>

    </div> >


    <div id="game">
	    <div id="info">
		    Score: <span id="score">0</span>
		    <br>
		    <span id="timer">0:00</span>
		    <br>
		    Volume: <span id ="volume_used">0</span>
		    <br>
	    </div>
    </div>


	<script>

		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

		var container, stats;
		var camera, scene, renderer, projector;
		var mouse2D, mouse3D, raycaster;

		var theta = 45 * 0.5;
		var blockNoise = new Audio("sounds/wood-cracking-1.wav");
		var collisionNoise = new Audio("sounds/beep-03.mp3");

		var rollOverMesh, rollOverMaterial;
		var i, intersector;
		var gameBoardOrientation;
		var controls, time = Date.now();

		var instructions = document.getElementById( 'instructions' );
		var timer = document.getElementById( 'timer');
		var volume_doc = document.getElementById( 'volume_used' );
		var blocker = document.getElementById("blocker");

		var STEP_SIZE = 50;
		var ALIVE_TIME = 60000.0;	// time during which the block is alive, in milliseconds
		var FLOOR_SIZE = 1000;
		var FLOOR_SIZE_HALF = FLOOR_SIZE / 2;
		var INIT_OPACITY = 0.7;

		var pos_illegal_code = 0;

		var elapsedTime, timeRemaining, mins, secs;

        // keeping track of max and min of x,y,z coordinates
        var min_x, min_y, min_z, max_x, max_y, max_z;
        var box_material = new THREE.LineBasicMaterial( { color: 0x000000 } );
        var boundingBox = null, cube_vol = 0;

        // list to hold blocks we created
        var block_list = new Array();

        var gameInProgress = false;

		init();
		animate();

		function init() {
			// initialize min max value
			min_x = min_y = min_z = Number.MAX_VALUE;
			max_x = max_y = max_z = Number.MIN_VALUE;

			container = document.getElementById( 'game' );
			document.body.appendChild( container );

			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
            camera.position.x = 5;
            camera.position.y = 325;
            camera.position.z = 694;
            camera.lookAt(new THREE.Vector3(25,25,25));

			scene = new THREE.Scene();
			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setClearColor( 0xf0f0f0, 1 );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMapEnabled = true;

			controls = new THREE.OrbitControls( camera , renderer.domElement );
			controls.rotateSpeed = 0.5;
			controls.minPolarAngle = 0.0;
			controls.maxPolarAngle = Math.PI * 4 / 9;
			scene.add( controls );

			// picking

			projector = new THREE.Projector();
			mouse2D = new THREE.Vector3( 0, 10000, 0.5 );

			// basic scene
			var floor = new Wall(FLOOR_SIZE);
			floor.plane.receiveShadow = true;
			floor.addToScene(scene);

			// placeholder so there's no error
			rollOverMesh = new THREE.Mesh();

			// Lights
			var ambientLight = new THREE.AmbientLight( 0x3c3c3c );
			scene.add( ambientLight );

			var directionalLight = new THREE.DirectionalLight( 0xffffff );
			directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
			directionalLight.intensity = 0.8;
			scene.add( directionalLight );

			directionalLight = new THREE.DirectionalLight( 0xffffff );
			directionalLight.position.set( -1, 0.75, -0.5 ).normalize();
			directionalLight.intensity = 0.8;
			scene.add( directionalLight );

			var shadowLight = new THREE.DirectionalLight( 0xffffff );
			shadowLight.position.set( 0, 1, 0 ).normalize();
			shadowLight.castShadow = true;
			shadowLight.shadowCameraNear = -1000;
			shadowLight.shadowCameraFar = 10;
			shadowLight.onlyShadow = true;
			scene.add( shadowLight );

			container.appendChild( renderer.domElement );

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			container.appendChild( stats.domElement );

			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			document.addEventListener( 'keydown', onDocumentKeyDown, false );
			document.addEventListener( 'keyup', onDocumentKeyUp, false );
			window.addEventListener( 'resize', onWindowResize, false );

		}

		function animate() {
			requestAnimationFrame( animate );
			controls.update();
			render();
			stats.update();
		}


		function render() {
			raycaster = projector.pickingRay( mouse2D.clone(), camera );

			renderer.render( scene, camera );
			time = Date.now();

			if (Math.abs(camera.position.x) > Math.abs(camera.position.z)) {
				if (camera.position.x < 0) {
					gameBoardOrientation = 2;
				} else {
					gameBoardOrientation = 3;
				}
			} else {
				if (camera.position.z < 0) {
					gameBoardOrientation = 4;
				} else {
					gameBoardOrientation = 1;
				}
			}

			if (rollOverMesh.material.opacity < 1.0) {
				// update time
				elapsedTime = time - BlockGenerator.generatedTime;
				timeRemaining = Math.max(ALIVE_TIME - elapsedTime, 0);
				secs = Math.floor(timeRemaining / 1000.0);
				mins = Math.floor(secs / 60);
				timer.innerHTML = ("0" + mins).slice(-2) + ":" + ("0" + secs).slice(-2);

				// update opacity
				rollOverMesh.material.opacity = INIT_OPACITY + elapsedTime / ALIVE_TIME * (1 - INIT_OPACITY);

				// check if we need new block
				if (rollOverMesh.material.opacity >= 1.0) {
					add_voxel();
				}
			}
			
		}

	</script>

</body>


</html>

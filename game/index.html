<!DOCTYPE html>
<html lang="en">

<head>
	<title>Block party!</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>

	<!-- javascript libraries -->
	<script src="js/libs/three.min.js"></script>
	<script src="js/libs/stats.min.js"></script>

	<script src="js/libs/PointerLockControls.js"></script>
	<script src="js/libs/Detector.js"></script>
	<script src="js/libs/ConvexGeometry.js"></script>
	<script src="js/libs/OrbitControls.js"></script>

	<!-- our own javascript objects -->
	<script src="js/Room.js"></script>
	<script src="js/Wall.js"></script>
	<script src="js/BlockGenerator.js"></script>

	<!-- other javascript functions -->
	<script src="js/controls.js"></script>
	<script src="js/gameUtils.js"></script>

<!--     <div id="blocker">

        <div id="instructions">
            <span style="font-size:40px">Click to play</span>
            <br />
            (W,A,S,D = Move, SPACE = Jump, MOUSE = Look, CLICK = Place Voxel)
        </div>

    </div> -->

    <div id="game">
	    <div id="info">
		    Score: <span id="score">0</span>
		    <br>
		    <span id="timer">0:00</span>
		    <br>
		    Volume: <span id ="volume_used">0</span>
		    <br>
	    </div>
    </div>


	<script>

		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

		var container, stats;
		var camera, scene, renderer;
		var projector, plane, cube;
		var mouse2D, mouse3D, raycaster,
		rollOveredFace, isShiftDown = false,
		theta = 45 * 0.5, isCtrlDown = false,
		isEqualsDown = false, isDashDown = false;
		var blockNoise = new Audio("sounds/wood-cracking-1.wav");
		var collisionNoise = new Audio("sounds/beep-03.mp3");

		var rollOverMesh, rollOverMaterial;
		var rollOverColor;
		var voxelPosition = new THREE.Vector3(), tmpVec = new THREE.Vector3(), normalMatrix = new THREE.Matrix3();
		var cubeGeo, cubeMaterial;
		var i, intersector;
		var gameBoardOrientation;
		var shadowLight;

		var controls, time = Date.now();
		var instructions = document.getElementById( 'instructions' );
		var timer = document.getElementById( 'timer');
		var volume_doc = document.getElementById( 'volume_used' );
		var mouseFlag = true;

		var STEP_SIZE = 50;
		var ALIVE_TIME = 60000.0;	// time during which the block is alive, in milliseconds
		var FLOOR_SIZE = 1000;
		var FLOOR_SIZE_HALF = FLOOR_SIZE / 2;
		var INIT_OPACITY = 0.7;

		var pos_illegal_code = 0;

		var elapsedTime, timeRemaining, mins, secs;

		//ADD
        //keeping track of max and min of x,y,z coordinates
        var min_x, min_y, min_z, max_x, max_y, max_z;
        var box_material = new THREE.MeshBasicMaterial({ color: 0xFFFFCC });
        box_material.transparent = true;
        box_material.opacity = 0.5;
        var cube = null, cube_vol = 0;
        //list to hold blocks we created
        var block_list = new Array();

		// includePointerLockControls();
		init();
		animate();

		function init() {
			container = document.getElementById( 'game' );
			// container = document.createElement( 'div' );
			document.body.appendChild( container );

			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
            camera.position.x = 5;
            camera.position.y = 325;
            camera.position.z = 694;
            camera.lookAt(new THREE.Vector3(25,25,25));

			scene = new THREE.Scene();
			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setClearColor( 0xf0f0f0, 1 );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMapEnabled = true;

			controls = new THREE.OrbitControls( camera , renderer.domElement );
			controls.rotateSpeed = 0.5;
			controls.minPolarAngle = 0.0;
			controls.maxPolarAngle = Math.PI * 4 / 9;
			scene.add( controls );

			// start with random block
			rollOverMesh = BlockGenerator.getRandomBlock();

			scene.add( rollOverMesh );
			rollOverMesh.position.x = 25; rollOverMesh.position.y = 25; rollOverMesh.position.z = 25;

			// picking

			projector = new THREE.Projector();
			mouse2D = new THREE.Vector3( 0, 10000, 0.5 );

			// basic scene
			var floor = new Wall(FLOOR_SIZE);
			floor.plane.receiveShadow = true;

			floor.addToScene(scene);

			// Lights

			var ambientLight = new THREE.AmbientLight( 0x3c3c3c );
			scene.add( ambientLight );

			var directionalLight = new THREE.DirectionalLight( 0xffffff );
			directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
			directionalLight.intensity = 0.8;
			scene.add( directionalLight );

			directionalLight = new THREE.DirectionalLight( 0xffffff );
			directionalLight.position.set( -1, 0.75, -0.5 ).normalize();
			directionalLight.intensity = 0.8;
			scene.add( directionalLight );

			shadowLight = new THREE.DirectionalLight( 0xffffff );
			shadowLight.position.set( 0, 1, 0 ).normalize();
			shadowLight.castShadow = true;
			shadowLight.shadowCameraNear = -1000;
			shadowLight.shadowCameraFar = 10;
			shadowLight.onlyShadow = true;
			scene.add( shadowLight );

			// var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
			// hemiLight.color.setHSL( 0.6, 1, 0.6 );
			// hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			// hemiLight.position.set( 0, 500, 0 );
			// scene.add( hemiLight );

			// making a bounding box
			// minX =  0, minY = 0, minZ = 0, maxX = 50, maxY = 50, maxZ = 50;
			// var bBox_min = new THREE.Vector3 (minX, minY, minZ);
			// var bBox_max = new THREE.Vector3 (maxX, maxY, maxZ);
			// var bBox_new = new THREE.Box3 (bBox_min, bBox_max);

			// scene.add (bBox_new);


			container.appendChild( renderer.domElement );

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			container.appendChild( stats.domElement );

			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			document.addEventListener( 'keydown', onDocumentKeyDown, false );
			document.addEventListener( 'keyup', onDocumentKeyUp, false );
			window.addEventListener( 'resize', onWindowResize, false );

		}

		var txtNode = document.createTextNode("Hello. This is a new node."); 

		function animate() {
			requestAnimationFrame( animate );
			controls.update();
			render();
			stats.update();
		}


		function render() {
			raycaster = projector.pickingRay( mouse2D.clone(), camera );

			//added for bounding box
			
			// if (isShiftDown==true){
			// 	scene.add(cube);
			// }
			score.innerHTML = '' + Math.round((BlockGenerator.totalVolume)/(cube_vol/Math.pow(STEP_SIZE,3) )*100)+ '%';

			renderer.render( scene, camera );
			time = Date.now();

			if (Math.abs(camera.position.x) > Math.abs(camera.position.z)) {
				if (camera.position.x < 0) {
					gameBoardOrientation = 2;
				} else {
					gameBoardOrientation = 3;
				}
			} else {
				if (camera.position.z < 0) {
					gameBoardOrientation = 4;
				} else {
					gameBoardOrientation = 1;
				}
			}

			if (rollOverMesh.material.opacity < 1.0) {
				// update time
				elapsedTime = time - BlockGenerator.generatedTime;
				timeRemaining = Math.max(ALIVE_TIME - elapsedTime, 0);
				secs = Math.floor(timeRemaining / 1000.0);
				mins = Math.floor(secs / 60);
				timer.innerHTML = ("0" + mins).slice(-2) + ":" + ("0" + secs).slice(-2);

				// update opacity
				rollOverMesh.material.opacity = INIT_OPACITY + elapsedTime / ALIVE_TIME * (1 - INIT_OPACITY);

				// check if we need new block
				if (rollOverMesh.material.opacity >= 1.0) {
					add_voxel();
				}
			}
			
		}

	</script>

</body>


</html>
